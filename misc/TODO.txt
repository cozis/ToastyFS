[X] Implement proper operation handles that allow users to wait for specific events
[X] Implement metadata server WAL
[X] Check that the corner case where read and writes go over the length of the file work correctly
[X] Return the number of bytes read or written in the ToastyFS_Result struct
[X] Add a change counter to FileTree. The counter is initialized to 0 and updated any time the tree is changed. When a new file is created, the current change counter is assigned to it. This makes it possible to verify that the file didn't change in between read and write operations without that clumsy previous hash list and previous chunk size.
[ ] Clean up the read operation for clients
[ ] Make parallel uploads/downloads configurable
[ ] Recalculate next write locations whenever a write occurs, not at each read
[ ] add logging (when chunk servers connect and disconnect to the metadata server)
[ ] Should list scenarios that need testing, like those where chunks would be dropped
[ ] Update DESIGN.txt and the code to remove the chunk list message. The information of chunks held by chunk servers is now transmitted to the metadata server during state updates
[ ] clean up the replication factor business
[ ] Add failt injections to the simulation
[ ] Add authentication
[ ] Add release build and allow switching between debug, release, coverage, sanitizer builds while calling make
[ ] When an operation is committed to the WAL, it may then fail due to not deterministic reasons (out of memory). When the metadata server restarts and replays the log, the operation may succede and cause the system to diverge from the last instance of the process. Is this not a problem? How do we solve it?
[ ] Add notes on who inspired the testing approach
[ ] Add notes on benchmarks and that we don't do batching
[ ] Fix endianess when writing to network and the WAL
[ ] WAL entry checksum
[ ] Check write() errors when appending WAL entries
[ ] When WAL entries are partially written, remove partial data and fail
[ ] Find a way to ensure listing operations of large directories are handled
[ ] What happens if a client adds a chunk such that the hash already exists in the system? The client doesn't know it exists already. Will this lead to over-replication?
[ ] Rename generation counters to version numbers
[ ] Add a flag for write operations to create the file if it doesn't exist alraedy
